#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{times}
\usepackage{moreverb}
\usepackage[dvips]{graphicx}
\usepackage{fancyhdr}
\renewcommand{\chaptermark}[1]{markboth{#1}{}}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,LO]{\nouppercase{\leftmark}}
\fancyhead[RE,RO]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}
\end_preamble
\language spanish
\inputencoding auto
\fontscheme times
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage widemarginsa4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title


\noun on 
Plimus Circus
\layout Author


\emph on 
Isaac Jurado Peinado
\newline 
Esteban Martínez Tristancho
\emph default 

\newline 

\emph on 

\newline 

\newline 

\emph default 
Informática Gráfica I
\newline 

\newline 
Profesores:
\emph on 

\newline 
José María Buades Rubio
\newline 
María José Abásolo Guerrero
\newline 

\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter*
\pagebreak_top 
Introducción
\layout Standard
\added_space_bottom bigskip 
Hoy en día, las técnicas de simulación por ordenador han avanzado mucho
 en muy poco tiempo.
 Gracias al avance tecnológico del hardware que permite realizar estas simulacio
nes, ha surgido la necesidad de tener un estándar para desarrollar aplicaciones
 que puedan realizar simulaciones por ordenador.
 Como resultado de todo esto surgió OpenGL, uno de los estándares más extendidos
 hoy en día que permiten a programadores y usuarios avanzados realizar aplicacio
nes que incluyen cada vez más efectos 3D y escenas que son difíciles de
 distinguir sin son reales o generadas por ordenador.
\layout Standard
\added_space_bottom bigskip 
Como parte de la asignatura de 
\emph on 
Informática Gráfica I
\emph default 
 dentro del plan de estudios de la 
\emph on 
ingeniería técnica de informática de gestión
\emph default 
, se ha propuesto por parte del personal docente, la realización de una
 práctica que contemple muchas de las técnicas empleadas para la simulación
 y la renderización de escenas virtuales que están soportadas por OpenGL.
\layout Standard
\added_space_bottom bigskip 
Para que la práctica no sea muy extensa, debido al tiempo que se dispone
 para impartir esta asignatura, se ha propuesto la realización de un 
\series bold 
circo
\series default 
 en tres dimensiones, utilizando las técnicas y funciones que están descritas
 y soportadas por OpenGL y las librerías auxiliares.
 La mayoría de microprocesadores ensamblados en las tarjetas gráficas de
 las computadoras soportan este estándar; por lo cual, el código necesario
 para desarrollar estas escenas virtuales, es portable a multitud de plataformas
 y sobre diferentes sistemas operativos, que van desde entornos 
\emph on 
Unix
\emph default 
 hasta entornos basados en 
\emph on 
Windows
\emph default 
, y arquitecturas como 
\noun on 
i386
\noun default 
, hasta 
\noun on 
PowerPC
\noun default 
, pasando por 
\noun on 
Alpha
\noun default 
, 
\noun on 
Sparc
\noun default 
, 
\noun on 
SGI
\noun default 
 y muchas otras.
\layout Standard

Sin más demora, pasamos a explicar las diferentes etapas realizadas para
 la realización del 
\series bold 
circo
\series default 
 en 3D dentro de una escena virtual.
\layout Chapter

Etapa 1: Entorno de trabajo y primer programa en OpenGL
\layout Standard

La primera etapa se compone de la creación de un pequeño programa ejemplo
 para tener un primer contacto con OpenGL y familiarizarse con el entorno
 de trabajo y la herramienta Visual C++, para la creación del código fuente,
 que es la herramienta disponibles en los laboratorios de informática de
 la universidad.
 Llegados a este punto, y previa consulta con el personal docente sobre
 la posibilidad de utilizar otras herramientas, los componentes de esta
 práctica hemos decidido utilizar otras herramientas para la creación del
 código fuente basadas en otra plataforma distinta a la de Windows.
 Sin ánimo de entrar en polémica ni debate, y por diferentes motivos que
 son ajenos al objetivo de este informe, se ha decidido utilizar otras herramien
tas con las cuales, los desarrolladores de esta práctica están más familiarizado
s.
 Pasamos a enumerarlas brevemente:
\layout List
\labelwidthstring 00.00.0000


\series bold 
Vim
\series default 
 Un potente editor de texto para entornos 
\emph on 
Unix
\emph default 
 y basado en consola.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Make
\series default 
 Utilidad de línea de comandos para mantener grupos de programas.
 Útil para automatizar y minimizar las recompilaciones.
\layout List
\labelwidthstring 00.00.0000


\series bold 
CVS
\series default 
 Es un sistema de control de versiones, el cual permite mantener versiones
 antiguas de ficheros (normalmente código fuente), mantener un log de quién,
 cuando, y por qué se hicieron los cambios, etc.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Cvs2cl
\series default 
 Un programa que genera un 
\emph on 
ChangeLog
\emph default 
 a partir de los 
\emph on 
logs
\emph default 
 que proporciona CVS.
\layout List
\labelwidthstring 00.00.0000


\series bold 
Gcc
\series default 
 El compilador de C del proyecto 
\noun on 
GNU
\noun default 
.
\layout Standard

El ejemplo propuesto está compuesto por una ventana de tamaño definido la
 cual contiene tres polígonos que describen un triángulo, que a su vez,
 en conjunto, forman un triángulo en dos dimensiones que va rotando sobre
 un eje, con un difuminado de colores, puesto que en cada vértice de cada
 triángulo se le asigna un color distinto y OpenGL los interpola para obtener
 el color de cada punto que forma el triángulo.
 El resultado de la escena se puede ver en la figura 
\begin_inset LatexCommand \ref{fig:figura1-1}

\end_inset 

.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura1-1}
\layout Standard

\backslash 
caption{Primer programa en OpenGL.}
\backslash 
label{fig:figura1-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Standard
\added_space_top medskip 
Dicho ejemplo está extraído directamente de la página web de uno de los
 profesores y tomando como punto de partida dicho ejemplo, a través de las
 diferentes etapas, iremos adaptando el código fuente al ejemplo concreto
 de un circo en tres dimensiones.
\layout Standard
\added_space_top medskip 
Cabe destacar la utilización de las librerías GLUT para la creación de la
 ventana, la gestión de los eventos, tanto de teclado como de ratón, y otra
 funciones, de forma independiente de la plataforma.
\layout Chapter

Etapa 2: Doble buffer y escalado
\layout Standard
\added_space_bottom bigskip 
La segunda etapa consiste en la adaptación del ejemplo visto en la primera
 etapa para resolver una pequeña carencia visual, como es evitar que se
 vea cómo se repinta la escena cada vez.
 Para ello simplemente basta con utilizar la función incluida en la librería
 GLUT que permite la utilización de un doble buffer.
 Dicha función es 
\begin_inset Formula $glutSwapBuffers$
\end_inset 

.
\layout Standard
\added_space_bottom bigskip 
Es necesario invocar a la función 
\begin_inset Formula $glutSwapBuffers$
\end_inset 

 cada vez que se dibuja la escena.
 Por ello se incluye dentro de la función 
\emph on 
Display
\emph default 
.
 Aparte, está situada justo al final de dicha función para que una vez repintado
s todos los objetos, se pueda invocar a esta función para la utilización
 de otro buffer, para que mientras se está visualizando por pantalla el
 contenido de dicho buffer, se pueda ir escribiendo la nueva escena en otro
 buffer distinto.
 Con esto se consigue evitar la sensación de parpadeo de la imagen y se
 consigue una suavidad en el movimiento muy agradable a la vista.
 Entonces, es necesario activar este doble buffer con el parámetro 
\begin_inset Formula $GLUT\_ DOBLE$
\end_inset 

 que le pasamos a la función 
\begin_inset Formula $glutInitDisplayMode.$
\end_inset 


\layout Standard
\added_space_bottom bigskip 
También se añade un polígono cuadrado en medio del triángulo formado por
 tres triángulos más pequeños y una nueva funcionalidad.
 Esta funcionalidad es el escalado de la escena dependiendo del tamaño de
 la ventana, donde se mantiene la relación de aspecto.
 Aunque se estire o se encoja la ventana, el triángulo, en este caso, sigue
 manteniendo la relación entre la altura y la amplitud que tenía en un principio.
\layout Standard

Esto se implementa en la función 
\emph on 

\begin_inset Formula $Reshape$
\end_inset 


\emph default 
 a la cual se le pasan los parámetros de ancho y alto que forman la ventana.
 Aparte de esto, se centran los polígonos con respecto al ancho en número
 de 
\emph on 
pixels
\emph default 
 de la ventana, en el caso de que la amplitud sea mayor a la altura.
 En caso contrario, se centra con respecto a la altura.
\layout Chapter

Etapa 3: Escena 3D
\layout Standard

La siguiente etapa consiste en crear nuestra primera escena en tres dimensiones.
 Para ello, dibujamos un cubo sólido de un color determinado, colocamos
 la cámara en un punto determinado, y a través de la pulsación de una tecla,
 permitimos que el cubo vaya rotando con un ángulo de rotación predeterminada
 sobre dos ejes.
 Para apreciar de una forma más clara el movimiento del cubo, se ha dibujado
 un cubo 
\emph on 
alámbrico
\emph default 
 de tamaño un poco mayor que el cubo sólido y con las aristas de color negro.
 De esta forma se distinguen las aristas del cubo sólido y visualmente permite
 seguir la rotación del mismo.
 El resultado obtenido lo podemos ver en la figura 
\begin_inset LatexCommand \ref{fig:figura3-1}

\end_inset 

.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura3-1}
\layout Standard

\backslash 
caption{Escena 3D.}
\backslash 
label{fig:figura3-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Section

Funcionalidades empleadas de OpenGL
\layout Standard

De las funcionalidades que implementa OpenGL que han sido utilizadas en
 la escena, caben destacar dos debido a su importancia:
\layout Enumerate

Activar el test de profundidad.
 Esta utilidad, conocida con el nombre de 
\emph on 
Z-Buffer
\emph default 
, permite a OpenGL distinguir entre aquellos puntos de un objeto que están
 delante de otros puntos de otros objetos.
 Con ello se consigue dibujar únicamente aquellos puntos de los objetos
 que están más cerca del centro de proyección, y por ende, de la cámara
 desde donde se está visualizando la escena.
 Para activar dicho test, tenemos que llamar a la función 
\begin_inset Formula $glEnable$
\end_inset 

 pasándole como parámetro 
\begin_inset Formula $GL\_ DEPTH\_ TEST$
\end_inset 

.
 Una vez activado el 
\emph on 
z-buffer
\emph default 
, hay que emplear otro parámetro a la hora de invocar a la función 
\begin_inset Formula $glClear$
\end_inset 

 dentro de la función 
\emph on 
Display
\emph default 
.
 El parámetro es 
\begin_inset Formula $GL\_ DEPTH\_ BUFFER\_ BIT$
\end_inset 

.
\layout Enumerate

Posicionar la cámara en un punto determinado.
 Para ello utilizamos la función 
\begin_inset Formula $gluLookAt$
\end_inset 

, especificando los siguientes parámetros:
\begin_deeper 
\layout Enumerate


\begin_inset Formula $eye_{x},eye_{y},eye_{z}\rightarrow$
\end_inset 

 Punto en coordenadas mundo donde se sitúa la cámara.
\layout Enumerate


\begin_inset Formula $center_{x},center_{y},center_{z}\rightarrow$
\end_inset 

 Punto en coordenadas mundo al cual está mirando la cámara.
\layout Enumerate


\begin_inset Formula $up_{x},up_{y},up_{z}\rightarrow$
\end_inset 

 Vector que indica la inclinación de la cámara.
\end_deeper 
\layout Standard
\added_space_bottom medskip 
Antes de posicionar la cámara, es necesario indicar el volumen de visualización
 en el cual estarán los objetos a dibujar.
 En nuestro caso, se ha utilizado la función 
\begin_inset Formula $gluPerspective$
\end_inset 

 al cual le hemos indicado un ángulo de apertura de 90º.
\layout Standard

Para rotar los objetos, empleamos la función 
\begin_inset Formula $glRotatef$
\end_inset 

 donde le pasamos como parámetro la variable 
\emph on 
fAngulo
\emph default 
 que indica en todo momento el ángulo de rotación a aplicar.
 Dicho ángulo de rotación se aplica sobre un vector determinado formado
 por tres puntos.
 Estos tres puntos también se pasan como parámetros a 
\begin_inset Formula $glRotate$
\end_inset 

.
\layout Section

Comandos de teclado
\layout Standard

Debido a que es un ejemplo sencillo y no hemos querido invertir demasiado
 tiempo en implementar diferentes movimientos con varias teclas, pues esto
 se hará a partir de la próxima etapa, se ha implementado de forma sencilla
 la rotación de la escena a través de cualquier tecla.
 Para ello, hemos creado la función 
\emph on 
Rota
\emph default 
 que se encarga de tratar los eventos producidos por el teclado.
 En este caso, su única función es la de aumentar el ángulo almacenado en
 la variable 
\emph on 
fAngulo
\emph default 
 y llamar a la función 
\begin_inset Formula $glutPostRedisplay$
\end_inset 

, para redibujar la escena.
\layout Chapter

Etapa 4: Movimiento de cámara
\layout Standard
\added_space_bottom medskip 
Una vez llegados a este punto, ya nos centramos en la escena referente al
 circo en tres dimensiones.
 Dejamos de un lado los ejemplos vistos en los capítulos anteriores y nos
 volcamos sobre lo que será la práctica que nos atañe.
 Así que, una vez creado los diferentes objetos que componen el circo (carpa,
 gradas, postes, etc.) pasamos a realizar el movimiento de la cámara, que
 nos permitirá movernos por la escena con una gran libertad de movimientos.
\layout Standard
\added_space_bottom medskip 
Desde un principio, los componentes de este grupo, a la hora de realizar
 el movimiento de la cámara y movernos por la escena, tuvimos en mente la
 manejabilidad a este respecto de juegos como 
\emph on 
Quake III Arena
\emph default 
, que permiten una gran libertad de movimientos por cualquier parte de la
 escena.
 Así que, nos decidimos a implementar los diferentes movimientos para permitir
 un movimiento omnidireccional por la escena.
\layout Standard

En el módulo 
\series bold 
interaccion.c
\series default 
 está implementado todo el movimiento de cámara.
 Por lo tanto, pasamos a explicar con detalle los diferentes funcionalidades
 y movimientos implementados.
\layout Section

Perspectiva
\layout Standard

En nuestro caso, se ha decidido utilizar la función 
\begin_inset Formula $gluPerspective$
\end_inset 

 para definir una proyección perspectiva sobre la cual trabajaremos.
 Una vez hecho esto, realizamos los siguientes pasos para realizar el giro
 de la cámara:
\layout Enumerate

Trasladarnos al punto donde se encuentra la cámara.
\layout Enumerate

Girar la cámara horizontalmente (plano XZ).
\layout Enumerate

Girar la cámara verticalmente (plano ZY).
\layout Standard
\added_space_top smallskip 
El código que implementa el giro de la cámara es el siguiente:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
glRotatef((GLfloat)\,-angulo\_ v,\,1.0,\,0.0,\,0.0);\\
glRotatef((GLfloat)\,-angulo\_ h,\,0.0,\,1.0,\,0.0);\\
glTranslatef((GLfloat)\,-camara\_ x,(GLfloat)\,-camara\_ y,(GLfloat)\,-camara\_ z,);\end{array}\]

\end_inset 


\layout Section

Movimientos
\layout Standard
\added_space_bottom bigskip 
Los movimientos definidos con respecto al giro de la cámara y las correspondient
es teclas que lo generan son los siguientes:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Movimiento
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Descripción
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Tecla
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Delante
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Paso hacia adelante
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\uparrow$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Detrás
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Paso hacia atrás
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\downarrow$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Lateral izquierdo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Paso hacia la izquierda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\leftarrow$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Lateral derecho
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Paso hacia la derecha
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\rightarrow$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Arriba
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Elevarse
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Av.pág
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Abajo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Descender
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Re.pág
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top bigskip \added_space_bottom bigskip 
Así mismo, los movimientos generales y sus correspondientes teclas son:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Movimiento
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Descripción
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Tecla
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Izquierda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia la izquierda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

H, h
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Derecha
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia la derecha
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

K, k
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Arriba
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia arriba
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

U, u
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Abajo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia abajo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

J, j
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Situación
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Imprimir el estado actual de la cámara
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

P, p
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top bigskip \added_space_bottom bigskip 
Aparte de implementar estos giros y movimientos a través del teclado, se
 incluye la opción de girar la cámara con el ratón, siempre que se mantenga
 un botón pulsado, para realizar un movimiento más rápido:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Movimiento
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Descripción
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Eje
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Izquierda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia la izquierda
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

horizontal negativo (-X)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Derecha
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia la derecha
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

horizontal positivo (X)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Arriba
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia arriba
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

vertical positivo (Y)
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Abajo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Giro de la cámara hacia abajo
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

vertical negativo (-Y)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Section

Restricciones
\layout Standard

Para restringir el movimiento vertical y dar una sensación más realista,
 se ha añadido una comprobación para no permitir que la cámara se sitúe
 por debajo del suelo de la escena.
 Simplemente se trata de comprobar que a la hora de descender, no se sobrepase
 el límite correspondiente a las coordenadas que forman el suelo.
 Para ello basta con comprobar que la posición de la cámara con respecto
 al eje vertical no pasa el límite permitido.
\layout Section

Interior/exterior
\layout Standard
\added_space_bottom medskip 
Aunque en un principio aquí no definimos ningún movimiento general ni ningún
 giro de la cámara, es necesario hacer esta observación porque está relacionada
 con el movimiento de la cámara.
\layout Standard
\added_space_bottom medskip 
Para agilizar el movimiento y minimizar el coste computacional, se ha implementa
do una función: 
\emph on 
comprueba_situacion
\emph default 
, que permite calcular en todo momento si la posición de la cámara está
 en el interior del circo, o en el exterior.
 Es decir, se comprueba si la cámara está dentro de la carpa o fuera.
\layout Standard
\added_space_bottom medskip 
El hecho de que se implemente la carpa que forma el circo con 
\emph on 
evaluators
\emph default 
 hace la tarea un poco más compleja, ya que los cálculos necesarios para
 saber si la cámara está dentro o fuera de la carpa no son tan precisos
 como si se implementara con superficies planas, en vez de curvas.
 Por lo tanto, puede ocurrir que haya un momento dado en el que la cámara
 esté dentro de la carpa, pero todavía no se renderice la escena interior,
 ni los objetos que componen el interior del circo, debido a que la forma
 de la carpa es curvilínea, y para minimizar los cálculos, se ha optado
 por hacer comprobaciones respecto de la recta que definen los puntos superiores
 e inferiores de los límites de la carpa.
\layout Standard

Aún así, este efecto es mínimo y lo que se gana en disminuir el coste computacio
nal tiene más peso que la momentánea sensación de falsa realidad en puntos
 muy concretos de la escena.
\layout Chapter

Etapa 5: Luces y materiales
\layout Standard

La iluminación de la escena está compuesta por las siguientes luces:
\layout Itemize

Focos interiores: compuesto por tres focos para alumbrar el interior de
 la carpa.
\layout Itemize

Luz solar: una luz direccional par emular la luz solar.
\layout Itemize

Luz ambiental.
\layout Standard
\added_space_bottom medskip 
OpenGL permite un máximo de ocho luces.
 Así pues, se han activado cinco de ellas para realizar la iluminación.
 La primera corresponde a la luz solar, las tres siguientes corresponden
 a los focos interiores, y las otra corresponde a la luz ambiental interior.
\layout Standard
\added_space_bottom medskip 
Pasamos pues a activar la iluminación local que está soportada por OpenGL.
 Esto se lleva a cabo dentro de la función 
\emph on 
init_luces_niebla
\emph default 
, en el módulo 
\series bold 
escena.c
\series default 
,y se realiza invocando a la función 
\begin_inset Formula $glEnable$
\end_inset 

 y pasándole como parámetro 
\begin_inset Formula $GL\_ LIGHTING$
\end_inset 

.
 Ahora bien, no basta con activar la iluminación local, sino que es necesario
 activar las diferentes luces y definir las propiedades que tendrán (atenuación,
 componente ambiente, difusa y especular, ángulo de apertura, etc.).
\layout Standard
\added_space_bottom medskip 
También se han activado las propiedades del material del que estará compuesto
 cada objeto, es decir, de qué forma reaccionará cada objeto con la luz
 que le llegue, pues hay objetos que son más brillantes y otros más mates,
 y esto es debido a su composición.
 Para activar las propiedades del material, se invoca a la función 
\begin_inset Formula $glEnable$
\end_inset 

 y se le pasa como parámetro 
\begin_inset Formula $GL\_ COLOR\_ MATERIAL$
\end_inset 

.
 Las propiedades de los materiales se aplican tanto a la cara posterior
 y a la cara anterior de cada objeto, por ello, empleamos la función 
\begin_inset Formula $glColorMaterial$
\end_inset 

 y le pasamos como parámetro 
\begin_inset Formula $GL\_ FRONT\_ AND\_ BACK$
\end_inset 

 y 
\begin_inset Formula $GL\_ AMBIENT\_ AND\_ DIFFUSE$
\end_inset 

.
\layout Standard

Se ha añadido una opción en el menú para activar la iluminación o desactivarla.
 Este menú se puede mostrar con solo pulsar el botón derecho del ratón en
 cualquier punto de la ventana que contiene la escena virtual.
\layout Section


\begin_inset LatexCommand \label{sec:Focos-interiores}

\end_inset 

Focos interiores
\layout Standard
\added_space_bottom medskip 
En el interior de la carpa se han colocado tres focos de forma que los tres
 focos están centrados con respecto al interior de la carpa.
 En el momento en el que la cámara se sitúa dentro de la carpa, se activan
 estas luces y se desactiva la luz exterior.
\layout Standard
\added_space_bottom medskip 
El escenario no es más que un rectángulo dividido a su vez en muchos cuadrados
 para que a la hora de iluminar el escenario, no se ilumine todo el escenario
 de golpe, sino simplemente aquellas zonas que se vean afectadas por los
 focos.
 Debido a que OpenGL implementa la iluminación de polígonos basándose en
 la iluminación que le llega a cada vértice y no a cada punto del polígono,
 se ha tenido que dividir el rectángulo que forma el escenario en rectángulos
 más pequeños.
\layout Standard
\added_space_bottom medskip 
Como se puede observar en la figura 
\begin_inset LatexCommand \ref{fig:figura5-1}

\end_inset 

, uno de ellos ilumina el centro de la carpa, que está compuesta por la
 arena que forma el escenario.
 Los otros dos focos iluminan las gradas y parte del escenario y al estar
 animados, van iluminando de forma rotativa, las gradas laterales y las
 gradas frontales
\begin_inset Foot
collapsed true

\layout Standard

A la hora de visualizar los efectos producidos por la iluminación de los
 focos en el interior de la carpa, han surgido una serie de problemas en
 el hecho de que con diferentes tarjetas, y empleando el mismo código, en
 un caso, los focos interiores se movían con respecto a la rotación deseada,
 pero en otro caso, se movían por otro camino distinto.
 Después de probar e investigar el problema a fondo, se ha conseguido averiguar
 que el fallo era debido a la implementación de las librerías DRI necesarias
 para soportar la aceleración por hardware de las tarjetas ATI en Linux.
 El problema estaba al emplear las funciones 
\begin_inset Formula $glPushAttrib$
\end_inset 

 y 
\begin_inset Formula $glPopAttrib$
\end_inset 

.
\end_inset 

.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura5-1}
\layout Standard

\backslash 
caption{Focos interiores.}
\backslash 
label{fig:figura5-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Standard
\added_space_top medskip \added_space_bottom bigskip 
Con las funciones 
\begin_inset Formula $glLight$
\end_inset 

 y 
\begin_inset Formula $glLightv$
\end_inset 

 se definen las propiedades de cada luz.
 En este caso las tres luces interiores corresponden a las luces 
\begin_inset Formula $GL\_ LIGHT1,\, GL\_ LIGHT2,\, GL\_ LIGHT3$
\end_inset 

 de OpenGL.
 Para cada una de ellas se definen las siguientes propiedades:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Parámetro
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Significado
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_AMBIENT
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

intensidad ambiente de la luz
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_DIFFUSE
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

intensidad difusa de la luz
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_SPECULAR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

intensidad especular de la luz
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_POSITION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

(x,y,z,w) posición de la luz
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_SPOT_DIRECTION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

(x,y,z,w) dirección de la luz
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_SPOT_EXPONENT
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

exponente del foco
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_SPOT_CUTOFF
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

ángulo de apertura del foco
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_CONSTANT_ATTENUATION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

factor de atenuación constante
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_LINEAR_ATTENUATION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

factor de atenuación lineal
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

GL_QUADRATIC_ATTENUATION
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

factor de atenuación cuadrático
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Section

Luz solar
\layout Standard
\added_space_bottom medskip 
Para conseguir una escena más realista se ha añadido una luz direccional
 que emula la luz solar y que está situada en el exterior del circo.
 Esta luz corresponde a la luz 
\begin_inset Formula $GL\_ LIGHT0$
\end_inset 

 de OpenGL.
 La luz solar se activa en el momento en el que la posición de la cámara
 está situada fuera de la carpa, y a su vez se desactivan las luces interiores
 (ver figura 
\begin_inset LatexCommand \ref{fig:figura5-2}

\end_inset 

).
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura5-2}
\layout Standard

\backslash 
caption{Luz solar (exterior).}
\backslash 
label{fig:figura5-2}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Standard
\added_space_bottom medskip 
Está claro que se tendrán que definir las mismas propiedades que las luces
 que hacen de focos interiores, pero tendrán unos valores distintos.
 De hecho, el ángulo de apertura de la luz solar será de 180º.
 La esfera que forma el sol, tiene unos parámetros configurables, como son:
 el radio de la escena y el nivel de detalle.
\layout Standard

Es posible mover la luz solar por la escena.
 Los movimientos y sus teclas asociadas son:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Descripción
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\series bold 
Tecla
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Moverse en el eje X
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

a-z
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Moverse en el eje Y
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

s-x
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Moverse en el eje Z
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

d-c
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Convertir luz direccional en luz posicional
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

w
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Section

Luz ambiente
\layout Standard
\added_space_bottom medskip 
Para permitir una mejor iluminación en el interior de la carpa, se ha incluido
 una luz ambiental que se activa únicamente cuando la cámara se sitúa dentro
 de la carpa, y que se desactiva en el momento en el que la cámara se sitúa
 en el exterior de la carpa.
\layout Standard

Esta luz corresponde a la luz 
\begin_inset Formula $GL\_ LIGHT5$
\end_inset 

 de OpenGL.
 Igual que los focos interiores, esta luz ambiental se activa y desactiva
 junto con ellas.
 
\layout Section

Materiales
\layout Standard

Para definir las características de los objetos, hemos empleado estas dos
 funciones 
\begin_inset Formula $glMaterialf$
\end_inset 

 y 
\begin_inset Formula $glMaterialfv$
\end_inset 

.
 A cada uno de los objetos en la escena se le han definido las propiedades
 de brillo, componente especular, etc.
 Un ejemplo de ello es lo siguiente:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
\ldots\\
glMaterialfv(GL\_ FRONT,\, GL\_ SPECULAR,\, brillo);\\
glMaterialf(GL\_ FRONT,\, GL\_ SHININESS,\, valor\_ decimal(c,p\_ brillo);\\
\ldots\end{array}\]

\end_inset 


\layout Chapter

Etapa 6: Shading
\layout Standard
\added_space_bottom medskip 
En nuestra siguiente etapa, siguiendo el objetivo de realizar una escena
 virtual lo más realista posible, se ha añadido el sombreado (
\emph on 
shading
\emph default 
).
 No hay que confundirlo con las sombras (
\emph on 
shearing
\emph default 
) que ese es otro tema aparte y no está soportado directamente por OpenGL.
\layout Standard
\added_space_bottom medskip 
El sombreado da un efecto más suavizado a las caras de los polígonos que
 forman los objetos, definiendo un vector normal para cada vértice que forma
 el polígono, de forma que la luz que se refleja sea constante e interpolada
 entre dos caras contiguas de un mismo polígono.
\layout Standard
\added_space_bottom medskip 
Está claro que activar el sombreado requiere un mayor coste computacional,
 pero vale la pena invertir más en coste computacional pues el resultado
 final es mucho mejor visualmente y gráficamente.
 Aún así, con las tarjetas gráficas de hoy en día, y en una escena 
\emph on 
sencilla
\emph default 
 como la del 
\series bold 
circo
\series default 
, no ralentiza mucho el sistema ni el tiempo de renderizado.
\layout Standard
\added_space_bottom medskip 
Activar o desactivar el sombreado es posible realizarlo pulsando la tecla
 
\begin_inset Formula $espacio$
\end_inset 

 o bien eligiendo la opción 
\emph on 
Modelo de Shading FLAT
\emph default 
 o 
\emph on 
Modelo de Shading SMOOTH
\emph default 
, respectivamente, del menú auxiliar, que se muestra pulsando con el botón
 derecho del ratón en cualquier punto de la ventana que contiene la escena.
 OpenGL permite renderizar una escena con el sombreado o sin él.
 Tenemos dos tipos de sombreado que podemos habilitar llamando a la función
 
\begin_inset Formula $glShadeModel$
\end_inset 

:
\layout Enumerate


\begin_inset Formula $GL\_ FLAT$
\end_inset 

.
 Selecciona el color calculado de un vértice y lo asigna a todos 
\emph on 
pixels
\emph default 
 generados mediante la rasterización de una única primitiva.
\layout Enumerate


\begin_inset Formula $GL\_ SMOOTH$
\end_inset 

.
 Este es el tipo de sombreado que viene por defecto en OpenGL.
 Interpola los colores calculados de los vértices a cada 
\emph on 
pixel
\emph default 
 resultante.
\layout Chapter

Etapa 7: Realismo
\layout Section

Texturas
\layout Standard
\added_space_bottom medskip 
La inclusión de texturas dentro de la escena que conforma el 
\series bold 
circo
\series default 
 supone un gran incremento cualitativo con respecto al resultado visual.
 De las opciones incluidas en este capítulo ésta es la que da a la escena
 un mayor realismo.
 Bien es cierto que el resto de opciones añadidas, como la niebla, superficies
 curvas, etc., incrementan la calidad visual de la escena final.
 Pero aún así, comparado con la inclusión de texturas, es un incremento
 menor de calidad, o al menos, es menos visible.
\layout Standard

Para habilitar la utilización de texturas en OpenGL, es necesario llamar
 a la función 
\begin_inset Formula $glEnable$
\end_inset 

 y pasarle como argumento uno de los siguientes parámetros:
\layout Itemize


\begin_inset Formula $GL\_ TEXTURE\_1D$
\end_inset 

.
 Si deseamos utilizar una textura de una dimensión.
 Este tipo de texturas están compuestas de una unidad de alto por 
\emph on 
n
\emph default 
 de ancho, de tal forma que simplemente es definir una línea de un punto
 de alto y con 
\emph on 
n
\emph default 
 unidades de ancho.
\layout Itemize


\begin_inset Formula $GL\_ TEXTURE\_2D$
\end_inset 

.
 Si deseamos utilizar una textura bidimensional.
 En el caso de esta práctica, este es el tipo de textura que empleamos,
 pues tiene 
\emph on 
n
\emph default 
 unidades de ancho por 
\emph on 
m
\emph default 
 unidades de alto.
 En este caso, cada unidad corresponde con un 
\emph on 
pixel
\emph default 
 de la imagen, y cada 
\emph on 
pixel
\emph default 
 está formado por cuatro enteros para definir el color y la transparencia
 (R,G,B,A).
\layout Itemize


\begin_inset Formula $GL\_ TEXTURE\_3D$
\end_inset 

.
 Si deseamos utilizar una textura tridimensional.
 Este tipo de texturas es útil, por ejemplo, a la hora de realizar mapas
 cartográficos, pero en nuestro caso, no la empleamos.
\layout Standard
\added_space_top medskip 
Así pues, para incluir texturas en la escena, es necesario realizar dos
 pasos.
\layout Subsection

Carga desde un fichero
\layout Standard
\added_space_bottom medskip 
Este paso no es necesario en el caso de que a la hora de poner una textura
 a un polígono determinado, ya tengamos cargada en memoria la imagen que
 contiene la textura deseada.
 En caso contrario, es necesario cargar la imagen que contiene la textura
 desde un fichero que esté en disco.
\layout Standard
\added_space_bottom medskip 
Aparte de implementar una función para copiar la imagen del fichero a una
 zona de memoria, para posteriormente, pasarle en puntero de esa zona de
 memoria a OpenGL, es necesario conocer en qué formato está la imagen almacenada
 en el fichero.
 
\layout Standard
\added_space_bottom smallskip 
En nuestro caso, adaptando un ejemplo encontrado en una página de Internet
\begin_inset Foot
collapsed true

\layout Standard

Ver apéndice 
\begin_inset LatexCommand \vref{sec:fuentes-de-informacion-nehe}

\end_inset 


\end_inset 

, cargamos texturas a través de imágenes que están en formato TGA sin comprimir.
 Llamamos a la función 
\emph on 
cargar_textura
\emph default 
 pasándole como parámetros, la estructura que contiene el fichero de configuraci
ón y el nombre del archivo que contiene la imagen.
 Ésta, a su vez, nos devuelve un puntero a memoria donde está cargada la
 imagen que contiene la textura, y que posteriormente pasaremos a OpenGL
 para enlazarla y usarla como la textura actual.
 Por ejemplo:
\layout Standard
\align center 

\begin_inset Formula $textura\,=\, cargar\_ textura(c,\, valor\_ cadena(c,\, b\_ text));$
\end_inset 


\layout Subsection

Mapeado
\layout Standard
\added_space_bottom medskip 
Este paso es obligatorio en todos los casos en los que se desee asignar
 una textura diferente a la que se asigna por defecto.
 OpenGL es una máquina de estados, por ello, si mapeamos una textura y no
 realizamos el enlace (
\emph on 
bind)
\emph default 
 a ninguna textura, OpenGL asigna la textura que estaba seleccionada en
 el paso anterior.
\layout Standard
\added_space_bottom medskip 
Entonces, antes de mapear la textura para un polígono en particular, es
 necesario enlazar la textura, diciéndole a OpenGL que la textura a utilizar
 por defecto es una determinada.
 Cuando queramos cambiar de textura para otro polígono, será necesario volver
 a realizar el enlace.
 En este caso se enlazará con la nueva textura.
\layout Standard

Así pues, los pasos a realizar son:
\layout Itemize


\emph on 
Enlazar la textura
\emph default 
.
 Indicar a OpenGL, la zona de memoria donde tenemos cargada la textura que
 ha de utilizar como la textura actual.
 Para ello utilizamos la función 
\begin_inset Formula $glBindTexture$
\end_inset 

 indicándole el tipo de textura y el puntero a la zona de memoria donde
 está cargada la textura.
\layout Itemize


\emph on 
Definir los puntos de control
\emph default 
 para indicar a qué punto de la imagen corresponde cada vértice y si es
 necesario repetir la textura, en el caso de que el polígono sea mayor que
 la textura, o si hay que hacer un escalado.
 Este escalado para adaptar la textura al tamaño del polígono, lo hace OpenGL.
 Hay dos formas de indicar estos puntos de control dependiendo de si utilizamos
 curvas de Bézier para generar un polígono, o no:
\begin_deeper 
\layout Itemize

Utilizando curvas de Bézier.
 Definiremos los puntos de control, en nuestro caso utilizamos la función
 
\begin_inset Formula $glMap2f$
\end_inset 

.
\layout Itemize

Sin utilizar curvas de Bézier.
 En el caso más simple utilizamos la función 
\begin_inset Formula $glTexCoord2f()$
\end_inset 

 para indicar qué puntos de la textura corresponden con qué vértices del
 polígono, del cual queremos mapear la textura.
 
\end_deeper 
\layout Standard

Un ejemplo, de cómo se ha implementado tanto el enlace como el mapeado es:
\layout Standard


\begin_inset LatexCommand \label{sec:ejemplo-codigo-texturas}

\end_inset 


\begin_inset Formula \[
\begin{array}{l}
\ldots\\
glBindTexture(GL\_ TEXTURE\_2D,\, textura);\\
glEnable(GL\_ MAP2\_ VERTEX\_3);\\
glEnable(GL\_ MAP2\_ TEXTURE\_ COORD\_2);\\
glMap2f(GL\_ MAP2\_ VERTEX\_3,\,0.0,\,1.0,\,6,\,2,\,0.0,\,1.0,\,3,\,2,\, limites);\\
glMap2f(GL\_ MAP2\_ TEXTURE\_ COORD\_2,\,0.0,\,1.0,\,2,\,2,\,0.0,\,1.0,\,4,\,2,\, tex);\\
glMapGrid2f(detalle,\,0.0,\,1.0,\, detalle,\,0.0,\,1.0);\\
glNormal3f(0.0,\,0.0,\,1.0);\\
glColor3f(1.0,\,1.0,\,1.0);\\
glEvalMesh2(GL\_ FILL,\,0,\, detalle,\,0,\, detalle);\\
\ldots\end{array}\]

\end_inset 


\layout Section

Niebla
\layout Standard
\added_space_bottom medskip 
El efecto de niebla está soportado por OpenGL de forma sencilla.
 Para activar la niebla basta con llamar a la función 
\begin_inset Formula $glEnable$
\end_inset 

 pasándole como parámetro 
\begin_inset Formula $GL\_ FOG$
\end_inset 

.
\layout Standard
\added_space_bottom medskip 
En el caso particular de nuestra práctica, habilitamos la niebla por defecto,
 pero damos la posibilidad al usuario de desactivarla.
 Para ello, en el módulo 
\series bold 
interaccion.c
\series default 
 tratamos el evento que habilita o deshabilita la niebla.
\layout Standard

A su vez, es necesario especificar diversas propiedades de la niebla a generar,
 como son:
\layout Itemize


\begin_inset Formula $GL\_ FOG\_ MODE$
\end_inset 

.
 Con esta propiedad le indicamos el tipo de ecuación a usar para calcular
 el factor de niebla.
 Básicamente se pueden definir tres tipos: linear, exponencial y exponencial
 al cuadrado.
\layout Itemize


\begin_inset Formula $GL\_ FOG\_ COLOR$
\end_inset 

.
 Con esta propiedad especificamos el color de la niebla.
\layout Itemize


\begin_inset Formula $GL\_ FOG\_ DENSITY$
\end_inset 

.
 Con esta otra propiedad especificamos la densidad que tendrá la niebla.
\layout Standard
\added_space_top medskip 
El código empleado para definir las propiedades de la niebla, es relativamente
 sencillo.
 En el módulo 
\series bold 
escena.c
\series default 
, dentro de la función 
\emph on 
init_luces_niebla
\emph default 
, definimos dichas propiedades:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
\ldots\\
glFogi(GL\_ FOG\_ MODE,\, GL\_ EXP2);\\
glFogfv(GL\_ FOG\_ COLOR,\, niebla\_ color);\\
glFogf(GL\_ FOG\_ DENSITY,\, valor\_ decimal(C,\, n\_ dens));\\
\ldots\end{array}\]

\end_inset 


\layout Standard

La niebla se puede activar o desactivar desde el menú auxiliar que se muestra
 pulsando con el botón derecho del ratón en cualquier punto de la ventana
 que contiene la escena.
\layout Section

Superficies de Bézier
\layout Standard
\added_space_bottom medskip 
Uno de los métodos más utilizados en los gráficos escalables es la descripción
 de las curvas como curvas de Bézier.
 Un ejemplo de este tipo de curvas lo podemos ver en la figura 
\begin_inset LatexCommand \ref{fig:figura7-3-1}

\end_inset 

.
 Consideramos que un segmento AB es una curva de Bézier.
 Entonces, los puntos E y F se llaman 
\series bold 
puntos de control 
\series default 
porque actúan como 
\emph on 
imanes
\emph default 
 que atraen a la curva y le dan su forma característica.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura7-3-1}
\layout Standard

\backslash 
caption{Superficies de Bézier.}
\backslash 
label{fig:figura7-3-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Standard
\added_space_bottom medskip 
A través de las curvas de Bézier, se pueden generar superficies curvas.
 Para ello se han utilizado ocho 
\emph on 
evaluators
\emph default 
 de orden 4
\begin_inset Formula $\times$
\end_inset 

4 para la carpa.
 Para generar una malla para las superficies planas del suelo, y conseguir
 el efecto de foco redondo, se han utilizado 
\emph on 
evaluators
\emph default 
 de orden 2
\begin_inset Formula $\times$
\end_inset 

2.
\layout Standard
\added_space_bottom medskip 
Para generar los puntos de control que formarán la malla, se utiliza la
 función 
\begin_inset Formula $glMapGrid2f$
\end_inset 

.
 A su vez, para crear la superficie (dos dimensiones) una vez definidos
 los puntos de control, se invoca a la función 
\begin_inset Formula $glEvalMesh2$
\end_inset 

.
 En el caso de que deseemos crear una línea curva (una dimensión), se utilizará
 la función 
\begin_inset Formula $glEvalMesh1$
\end_inset 

.
 Un ejemplo de esto lo podemos encontrar en el apartado 
\begin_inset LatexCommand \vref{sec:ejemplo-codigo-texturas}

\end_inset 

.
\layout Standard

Aparte de las dimensiones de la superficie y su forma, en función de la
 colocación de los puntos de control, es posible modificar el nivel de detalle
 a través del fichero de configuración.
\layout Section

Varias fuentes de luz
\layout Standard

Ver el apartado 
\begin_inset LatexCommand \vref{sec:Focos-interiores}

\end_inset 

.
\layout Section

Animación
\layout Standard
\added_space_bottom medskip 
Además de renderizar gran parte de la escena de objetos estáticos, se ha
 aplicado una animación a varios de los objetos en particular.
 En el caso de esta práctica, el circo contiene en su exterior un cartel
 publicitario.
 Así pues, para dar más realismo a la escena, se ha animado el cartel de
 forma que gire sobre si mismo con una velocidad determinada.
 La velocidad de giro se puede modificar a través del fichero de configuración
 
\series bold 
circo.cfg
\series default 
.
 También, en el interior del circo hay situados tres focos
\begin_inset Foot
collapsed true

\layout Standard

Ver el apartado 
\begin_inset LatexCommand \vref{sec:Focos-interiores}

\end_inset 


\end_inset 

 a los cuales se les ha aplicado una animación que consiste en que giren
 sobre si mismos con un ángulo de rotación determinados.
 De esta forma, las gradas del circo se van iluminando de forma alternativa.
\layout Standard
\added_space_bottom medskip 
Para crear la animación se ha creado una función llamada 
\emph on 
animacion 
\emph default 
en el módulo 
\series bold 
interaccion.c
\series default 
,
\series bold 
 
\series default 
la cual se encarga de ir cambiando el ángulo de giro cada vez que se produce
 un evento de reloj.
 A OpenGL tenemos que indicarle qué función será la encargada de tratar
 el evento de reloj o 
\emph on 
timer
\emph default 
 a través de la función 
\begin_inset Formula $glutTimerFunc$
\end_inset 

, donde además de pasarle el nombre de la función que crearemos nosotros,
 le pasamos el intervalo de tiempo en milisegundos a transcurrir entre un
 evento de reloj y el siguiente.
 Cada vez que tratamos un evento de reloj, es necesario volver a invocar
 a la función 
\begin_inset Formula $glutTimerFunc$
\end_inset 

 para que genere otro evento de reloj una vez transcurrido el intervalo
 de tiempo indicado.
\layout Standard

La animación se puede activar o desactivar desde el menú auxiliar que se
 muestra pulsando con el botón derecho del ratón en cualquier punto de la
 ventana que contiene la escena.
\layout Chapter

Extras
\layout Section

Parametrización del circo
\layout Standard

Es posible modificar las propiedades escalares de los objetos que componen
 la escena sin necesidad de recompilar el código fuente, gracias a la existencia
 de un fichero de configuración.
 Tales propiedades suelen ser: medidas de tamaño y distancia, niveles de
 detalle, niveles de intensidad y valores de cadena (ficheros de texturas).
\layout Subsection

Sintaxis
\layout Standard

Para asignar valor a una propiedad se utiliza la siguiente sintaxis:
\layout Standard
\added_space_top smallskip \added_space_bottom smallskip \align center 

\begin_inset Formula $nombre\_ propiedad=valor$
\end_inset 


\layout Standard

Donde 
\emph on 
valor
\emph default 
 puede ser un número entero, un número con punto flotante o una cadena de
 caracteres delimitada por comillas dobles.
 La clave 
\emph on 
nombre_propiedad
\emph default 
 deberá comenzar por una letra minúscula y sólo podrá constar de letras
 minúsculas y caracteres de subrayado '_'.
 Cada asignación puede ocupar, como máximo, una sola línea de hasta 80 caractere
s.
 Si se pasa de 80 caracteres, se ignoran.
 Las líneas en blanco o las que comiencen por '#' serán ignoradas.
 Por ejemplo:
\layout Standard


\begin_inset Formula \[
\begin{array}{lcl}
\ldots\\
ventana\_ ancho\_ inicial & = & 500\\
\ldots\\
camara\_ apertura\_ angular & = & 65.0\\
\ldots\\
suelo\_ exterior\_ textura & = & "cesped1.tga"\\
\ldots\end{array}\]

\end_inset 


\layout Subsection

Implementación del analizador
\layout Standard

Para cargar todos los valores del fichero de configuración en memoria, de
 una forma eficiente, utilizamos un 
\emph on 
árbol de tries
\emph default 
 o 
\emph on 
diccionario
\emph default 
.
 Esta estructura se adapta bien como solución ya que solo necesitamos tener
 implementadas las operaciones de 
\emph on 
inserción
\emph default 
 y 
\emph on 
consulta
\emph default 
.
 La estructura aprovecha las frecuentes coincidencias de los prefijos de
 los nombres de las propiedades, de tal forma que el árbol queda tal como
 se indica en la figura 
\begin_inset LatexCommand \ref{fig:figura8-1-2-1}

\end_inset 

.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figura8-1-2-1}
\layout Standard

\backslash 
caption{Árbol de tries o diccionario.}
\backslash 
label{fig:figura8-1-2-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Standard
\added_space_top medskip 
Cada nodo del árbol es un array de estructuras tal como esta:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
\mathbf{struct}\, nodo\,\{\\
\,\,\,\,\,\,\,\,\mathbf{struct}\, item\,*d;\\
\,\,\,\,\,\,\,\,\mathbf{int}\, tam;\\
\,\,\,\,\,\,\,\,\mathbf{int}\, ult;\\
\};\end{array}\]

\end_inset 


\layout Standard

Un nodo es un array de 
\emph on 
struct item
\emph default 
 tal como este:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
\mathbf{struct}\, item\,\{\\
\,\,\,\,\,\,\,\,\mathbf{char}\, c;\\
\,\,\,\,\,\,\,\,\mathbf{enum}\, tipo\, t;\\
\,\,\,\,\,\,\,\,\mathbf{union}\, valor\, v;\\
\};\end{array}\]

\end_inset 


\layout Standard

Cada 
\emph on 
item
\emph default 
 asocia un carácter 
\emph on 
c
\emph default 
 a un valor 
\emph on 
v
\emph default 
, y este valor 
\emph on 
v
\emph default 
 tiene un tipo 
\emph on 
t
\emph default 
 enumerado:
\layout Standard
\align center 

\begin_inset Formula $\mathbf{enum}\, tipo\,\{ CFG\_ NODO,\, CFG\_ ENTERO,\, CFG\_ DECIMAL,\, CFG\_ CADENA\}$
\end_inset 


\layout Standard

donde este tipo 
\emph on 
t
\emph default 
 define qué contiene 
\emph on 
valor,
\emph default 
 ya que 
\emph on 
valor
\emph default 
 es una unión como esta:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
\mathbf{union}\, valor\,\{\\
\,\,\,\,\,\,\,\,\mathbf{struct}\, nodo\,*sig;\\
\,\,\,\,\,\,\,\,\mathbf{int}\, entero;\\
\,\,\,\,\,\,\,\,\mathbf{float}\, decimal;\\
\,\,\,\,\,\,\,\,\mathbf{char}\,*cadena;\\
\};\end{array}\]

\end_inset 


\layout Standard

Así mismo, cada valor 
\emph on 
v
\emph default 
 puede ser:
\layout Itemize

Un puntero a un nodo, lo cual corresponde a un descenso en el árbol.
\layout Itemize

Un entero, lo cual corresponde al final de la rama y su correspondiente
 valor.
\layout Itemize

Un 
\emph on 
float
\emph default 
, lo cual corresponde al final de la rama y su correspondiente valor.
\layout Itemize

Un 
\emph on 
string
\emph default 
, lo cual corresponde al final de la rama y su correspondiente valor.
\layout Section


\emph on 
Display Lists
\layout Standard
\added_space_bottom medskip 
Debido a que prácticamente casi toda la escena está compuesta por elementos
 estáticos, realizar los cálculos de dimensionado de los objetos para cada
 
\emph on 
frame
\emph default 
 puede llegar a requerir un alto coste computacional.
 Para evitar recalcular la escena completa para cada movimiento de la cámara
 o de la animación, nos valemos de una funcionalidad que implementa OpenGL
 llamada 
\emph on 
display
\emph default 
 
\emph on 
lists
\emph default 
.
\layout Standard
\added_space_bottom medskip 
Las 
\emph on 
display
\emph default 
 
\emph on 
lists
\emph default 
 sirven para almacenar comandos OpenGL de una forma eficiente y que al ejecutar
 estos comandos almacenados, se realice también de forma eficiente y cómoda.
 Con el añadido de que los valores numéricos de cada comando también se
 almacenan, por lo que almacenamos las propiedades (vértices, normales,
 colores, etc.) de cada objeto.
\layout Standard

A la hora de crear una 
\emph on 
display list
\emph default 
 es necesario llamar a la función 
\begin_inset Formula $glGenLists$
\end_inset 

 pasando como parámetro el número de 
\emph on 
display lists 
\emph default 
que OpenGL creará vacías.
 Después, llamamos a la función 
\begin_inset Formula $glNewList$
\end_inset 

 para crear la 
\emph on 
display list
\emph default 
, pasándole el identificador devuelto por la función anterior y además indicando
 si queremos compilar y ejecutar la 
\emph on 
display list
\emph default 
 o simplemente compilarla, para un posterior uso.
 Por ejemplo:
\layout Standard


\begin_inset Formula \[
\begin{array}{l}
lista\,=\, glGenLists(1);\\
if\,(lista==0)\, return\,0;\\
\ldots\\
glNewList(lista,\, GL\_ COMPILE);\\
\ldots\,{\scriptstyle /*\, lista\, de\, comandos\, de\, OpenGL\,*/}\\
glEndList();\end{array}\]

\end_inset 


\layout Standard

Una vez creada la
\emph on 
 display list
\emph default 
 podemos emplearla en cualquier momento con simplemente llamar a la función
 
\begin_inset Formula $glCallList$
\end_inset 

 indicando el identificador de 
\emph on 
display list
\emph default 
 queremos emplear.
\layout Section


\emph on 
Cull Faces
\layout Standard
\added_space_bottom medskip 
En OpenGL el orden en el que se van procesando los vértices para constituir
 un polígono define la cara que se está dibujando.
 Por defecto OpenGL renderiza tanto la cara frontal como la cara trasera
 de un mismo polígono, por lo que puede suponer el doble de trabajo.
\layout Standard
\added_space_bottom medskip 
Es posible indicarle a OpenGL que únicamente renderice una de las dos caras
 de un polígono, según se ordenaron los vértices en sentido horario o anti-horar
io
\begin_inset Foot
collapsed true

\layout Standard

Además, podemos conmutar entre sentido horario y anti-horario para definir
 la cara delantera, con la función 
\begin_inset Formula $glFrontFace$
\end_inset 

.
\end_inset 

.
\layout Standard
\added_space_bottom medskip 
Activar esta funcionalidad es muy sencillo.
 Basta con llamar a la función 
\begin_inset Formula $glEnable$
\end_inset 

 pasándole como parámetro 
\begin_inset Formula $GL\_ CULL\_ FACE$
\end_inset 

.
 Posteriormente, podemos elegir la cara a omitir llamando a la función 
\begin_inset Formula $glCullFace$
\end_inset 

, que por defecto utiliza 
\begin_inset Formula $GL\_ BACK$
\end_inset 

.
\layout Standard

Esta funcionalidad permite agilizar el renderizado de la escena completa
 de una manera notable ya que evita renderizar gran parte de las caras no
 visibles de los polígonos, desde el punto de vista de la cámara por parte
 del usuario.
 Así pues, evita la realización de muchos cálculos por parte del hardware
 específico.
\layout Chapter
\start_of_appendix 
Estructura del código fuente
\layout Standard

Los módulos de código fuente que componen la aplicación en OpenGL que genera
 el 
\series bold 
circo
\series default 
 en tres dimensiones tienen la siguiente relación:
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
begin{figure}[ht!]
\layout Standard

\backslash 
begin{center}
\layout Standard

\backslash 
includegraphics[width=
\backslash 
textwidth]{../doc/figuraA-1}
\layout Standard

\backslash 
caption{Jerarquía e interrelación de los módulos.}
\backslash 
label{fig:figuraA-1}
\layout Standard

\backslash 
end{center}
\layout Standard

\backslash 
end{figure}
\end_inset 


\layout Chapter

Fuentes de información y bibliografía
\layout Itemize

OpenGL Programming Guide.
 Ed.
 Addison-Wesley.
 1995 (red book)
\layout Itemize


\begin_inset LatexCommand \htmlurl[Información general: ]{www.google.com}

\end_inset 


\layout Itemize


\begin_inset LatexCommand \label{sec:fuentes-de-informacion-nehe}

\end_inset 


\begin_inset LatexCommand \htmlurl[Ejemplos en OpenGL: ]{nehe.gamedev.net}

\end_inset 


\layout Itemize


\begin_inset LatexCommand \htmlurl[Texturas: ]{texturator.de}

\end_inset 


\layout Itemize


\begin_inset LatexCommand \htmlurl[Más texturas: ]{www.grsites.com/textures}

\end_inset 


\layout Itemize


\begin_inset LatexCommand \htmlurl[Información sobre la práctica: ]{dmi.uib.es/~josemaria}

\end_inset 


\layout Itemize

Apuntes de la asignatura dados en clase y existentes en Campus Extens.
\layout Chapter

Changelog
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
verbatimtabinput[4]{$HOME/work/grafica/ChangeLoggggg}
\end_inset 


\the_end
